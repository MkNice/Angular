import {
  AfterViewInit,
  ApplicationRef,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  NgZone,
} from '@angular/core';

@Component({
  selector: 'app-change-detection',
  templateUrl: './change-detection.component.html',
  styleUrls: ['./change-detection.component.scss'],
})
export class ChangeDetectionComponent implements AfterViewInit {
  public name: string = 'Hello';
  public obj = {
    name: 'georg',
    age: '12',
  };

  constructor(public ngzone: NgZone, public cdr: ChangeDetectorRef, private AR: ApplicationRef) {
    this.cdr.detach()
    
    this.AR.tick() // Вот этот вод метод тригерит ChangeDetector по всей приложухе. Это именно тот метод, который вызывается
    // после достижения рутового файлика, в системе, когда мы затригерили какой-то евент, в каком-то дочернем элементе,
    // система помечает эти файлики для изменений и снова же, когда мы достигаем рутового файла, то ангуляр запускает этот механизм

    // setTimeout(() => {
    //   this.obj.name = '123';
    //   this.obj.age = '123';
    //   this.obj = { name: '123', age: '123' };
    //   cdr.markForCheck();
    // }, 500);
  }
  ngAfterViewInit(): void {
    // Тут нельзя менять шаблон, без cdr
    console.log('after');
    
  }
  ngOnInit(){
    console.log('ngOnInit parent');
  }

  public doubleName() {
    this.name += this.name;

    setTimeout(() => {
      this.obj.name = '123';
      this.obj.age = '123';

      this.cdr.markForCheck();
    }, 500);
  }

  public field = 0

  public getRandomNumber(): void {
    this.field = Math.random();
  }
}
// ChangeDetector.onPush не отслеживает любые асинхроннные операции, ему нужно помогать, через cdr, можно использовать detectChanges
// либо markForCheck. Первый синхронный, второй асинхронный. Лучше использовать второй вариант. Потому что... второй видос надо чекнуть.

// Так же асинхронный код можно оберунть в NgZOne

// В общем, я понял что по сути, когда мы передаём какие-то данные через инпут, и эти данные должны получаться асинхронно. Если
// если мы будем точечно перезаписывать эти изменения, т.е. obj.age = data.age. То даже если мы скажем после этого чтобы chande
// detector проверил на изменния, то он ничего не увидит. Из-за того что он чекает ссылку, а не сами данные.
// Поэтому вывод прост, в асинхронных операция, меняй ссылку на объект, а не его содержимое.
// Есть ньюанс, если поместить этот код в метод, вызвать его, изменений, не будет. Ожидаемо, окей. Но если вызвать его ещё раз
// То тогда как раз таки, проявятся изменения, но, предыдущие изменения.

// Если мы напишем в интерполяции, какой-то метод, то он будет вызываться каждый раз, когда будет тригериться changeDetector.
// Поэтому можно спокойно сказать, что не нужно использовать какую-то сложную логику в интерполяции, создавать массивы, объекты...

// метод markForCheck находится в микро тасках.

// Если нет возможности использовать стратению изменений onPush, то можно инжектунть либу ngZone и пропатчить какое-то асинхронное
// действие. Имеется ввиду, что мы собсно вырубаем changeDetector для того куска кода который мы оборачиваем в метод runOutsideAngular
// и после уже сами должны контролировать перерендеринг шаблана.

/* Добавим парочку моментов.
  Во первыйх есть такие методы у cdr как detach/reatach. Что они делают? Полностью отрубают changeDetector у этого компонента
  и у всех дочерних. Но если мы мануально будет вызывать cdr то будет всё оки. Реатач, вновь запускает ChangeDetector

  LifeCycleHooks кое-как связан с changeDetector. Каким образом, да по сути, когда вызывается changeDetector, тогда и вызываются хуки
  а точнее, например doCheck. Он вызывается каждый раз когда тригирться CD. Он может использоваться чтобы как-то допольнять логику
  CD.

  Ещё один момент, если мы сделаем detach. То все жизненные циклы потомков компонента, будут деактивированы

  Бывает вот такая вот ошибка - NG0100: Expression has changed after it was checked
  Обычно она возникает из-за того что ты пытаешься изменить значение в мозгах компонента, после того как CD уже прошёлся
  по нему и синхронизировал шаблон и мозг.
  Например ты написал какой-то метод, и вызываешь его через интерполяцию и тебе этот метод всегда возвращает разные значения.
  Эта ошибка будет возникать так же если ты будешь изменять данные которые отрисовываются в шаблоне в хуке ngAfterViewInit.
  В этом случае тебе может помочь обычный cdr.detectChanges(). В случае с методом о котором я говорил чуток выше, не поможет.
  
  Почему это вообще просходит, потому что в режиме разработки приложения, у стратегии Default CD вызывается дважды.
  Поэтому тут и возникает замкнутый круг.
  CD тригериться, тригириться метод в интерполяции, значение меняется, запускается вновь CD, чтобы проверить точно ли данные
  все правильно засинхронизированы, а там уже другое значение и он такой WTF, и выплёвывает тебе ошибку.
  Если же ты ещё и будешь использовать markForCheck, то вообще сделаешь бессконечный цыкл.

  Есть ещё прикол с HostBinding и onPush. Когда будешь менять в асинхронном режиме стили, то тебе нужно будет использовать
  именно markForCheck, иначе никак. +onPush Должен быть везде, ну, думаю что ближайшие компоненты которые используют HostBinding.

  Так же момент что инстанс ChangeDetectorRef-а на каждом компоненте будет разный. Ну как минимимум логически подумай что, 
  когда ты вызываешь любой из методов markForCheck or DetectChanges, то помечается или проверятся именно этот компонент, а не ка-
  кой-то другой. Можно прикольнуться, и в случае с HostBinding, можно навесить на cdr декоратор SkipSelf, он возьмёт cdr
  родительского компонента и ты можешь вызывать теперь detectChanges, а не markForCheck.
  */